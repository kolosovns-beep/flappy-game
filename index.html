<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Flappy Bird</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #4ec0ca;
            touch-action: manipulation;
        }

        #gameContainer {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        #gameCanvas {
            display: block;
            background: #4ec0ca;
        }

        #difficultyScreen, #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        .screen-content {
            background: linear-gradient(180deg, #f7dc6f 0%, #f39c12 100%);
            border-radius: 20px;
            padding: 30px 40px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border: 4px solid #fff;
            max-width: 90%;
        }

        .title {
            font-family: 'Arial Black', sans-serif;
            font-size: 28px;
            color: #fff;
            text-shadow: 3px 3px 0 #2c3e50, -1px -1px 0 #2c3e50;
            margin-bottom: 20px;
        }

        .subtitle {
            font-family: Arial, sans-serif;
            font-size: 14px;
            color: #2c3e50;
            margin-bottom: 20px;
        }

        .score-display {
            font-family: 'Arial Black', sans-serif;
            font-size: 48px;
            color: #fff;
            text-shadow: 2px 2px 0 #2c3e50;
            margin: 10px 0;
        }

        .label {
            font-family: Arial, sans-serif;
            font-size: 16px;
            color: #2c3e50;
            margin-top: 10px;
        }

        .best-score {
            font-family: 'Arial Black', sans-serif;
            font-size: 24px;
            color: #27ae60;
            text-shadow: 1px 1px 0 #fff;
        }

        .difficulty-buttons {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .diff-btn {
            border: 3px solid #fff;
            border-radius: 15px;
            padding: 15px 30px;
            font-family: 'Arial Black', sans-serif;
            font-size: 18px;
            color: #fff;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            transition: transform 0.1s;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .diff-btn:active {
            transform: scale(0.95);
        }

        .diff-btn .diff-desc {
            font-family: Arial, sans-serif;
            font-size: 11px;
            font-weight: normal;
            opacity: 0.9;
            margin-top: 4px;
        }

        .btn-easy {
            background: linear-gradient(180deg, #27ae60 0%, #1e8449 100%);
            text-shadow: 2px 2px 0 #1e8449;
        }

        .btn-normal {
            background: linear-gradient(180deg, #3498db 0%, #2980b9 100%);
            text-shadow: 2px 2px 0 #2980b9;
        }

        .btn-hard {
            background: linear-gradient(180deg, #e74c3c 0%, #c0392b 100%);
            text-shadow: 2px 2px 0 #c0392b;
        }

        .play-btn {
            background: linear-gradient(180deg, #27ae60 0%, #1e8449 100%);
            border: 3px solid #fff;
            border-radius: 15px;
            padding: 15px 50px;
            font-family: 'Arial Black', sans-serif;
            font-size: 24px;
            color: #fff;
            text-shadow: 2px 2px 0 #1e8449;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            transition: transform 0.1s;
        }

        .play-btn:active {
            transform: scale(0.95);
        }

        .hidden {
            display: none !important;
        }

        .new-record {
            color: #e74c3c;
            font-family: 'Arial Black', sans-serif;
            font-size: 20px;
            text-shadow: 1px 1px 0 #fff;
            animation: pulse 0.5s ease-in-out infinite alternate;
        }

        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.1); }
        }

        .difficulty-badge {
            font-family: Arial, sans-serif;
            font-size: 14px;
            color: #fff;
            padding: 5px 15px;
            border-radius: 10px;
            margin-top: 10px;
            display: inline-block;
        }

        .badge-easy { background: #27ae60; }
        .badge-normal { background: #3498db; }
        .badge-hard { background: #e74c3c; }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>

        <div id="difficultyScreen">
            <div class="screen-content">
                <div class="title">FLAPPY BIRD</div>
                <div class="subtitle">Выбери сложность</div>
                <div class="difficulty-buttons">
                    <button class="diff-btn btn-easy" data-difficulty="easy">
                        НОВИЧОК
                        <span class="diff-desc">Медленно и просто</span>
                    </button>
                    <button class="diff-btn btn-normal" data-difficulty="normal">
                        ПРОФИ
                        <span class="diff-desc">Стандартная сложность</span>
                    </button>
                    <button class="diff-btn btn-hard" data-difficulty="hard">
                        ХАРДКОР
                        <span class="diff-desc">Для мазохистов</span>
                    </button>
                </div>
            </div>
        </div>

        <div id="gameOverScreen" class="hidden">
            <div class="screen-content">
                <div class="title">GAME OVER</div>
                <div class="label">Очки</div>
                <div class="score-display" id="finalScore">0</div>
                <div id="newRecordText" class="new-record hidden">НОВЫЙ РЕКОРД!</div>
                <div class="label">Лучший результат</div>
                <div class="best-score" id="bestScore">0</div>
                <div id="difficultyBadge" class="difficulty-badge badge-normal">ПРОФИ</div>
                <button class="play-btn" id="restartBtn">ЗАНОВО</button>
                <button class="diff-btn btn-normal" id="changeDiffBtn" style="margin-top: 10px; padding: 10px 20px; font-size: 14px;">
                    СМЕНИТЬ СЛОЖНОСТЬ
                </button>
            </div>
        </div>
    </div>

    <script>
        // Telegram WebApp initialization
        const tg = window.Telegram?.WebApp;
        if (tg) {
            tg.ready();
            tg.expand();
            tg.setHeaderColor('#4ec0ca');
            tg.setBackgroundColor('#4ec0ca');
        }

        // Game constants
        const BASE_WIDTH = 400;
        const BASE_HEIGHT = 600;

        // Difficulty settings
        const DIFFICULTIES = {
            easy: {
                name: 'НОВИЧОК',
                gravity: 0.35,
                jump: -8,
                pipeSpeed: 2,
                pipeGap: 200,
                spawnInterval: 2200
            },
            normal: {
                name: 'ПРОФИ',
                gravity: 0.5,
                jump: -9,
                pipeSpeed: 3,
                pipeGap: 160,
                spawnInterval: 1800
            },
            hard: {
                name: 'ХАРДКОР',
                gravity: 0.65,
                jump: -10,
                pipeSpeed: 4.5,
                pipeGap: 130,
                spawnInterval: 1400
            }
        };

        let currentDifficulty = 'normal';

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Screen elements
        const difficultyScreen = document.getElementById('difficultyScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const restartBtn = document.getElementById('restartBtn');
        const changeDiffBtn = document.getElementById('changeDiffBtn');
        const finalScoreEl = document.getElementById('finalScore');
        const bestScoreEl = document.getElementById('bestScore');
        const newRecordText = document.getElementById('newRecordText');
        const difficultyBadge = document.getElementById('difficultyBadge');

        // Game state
        let gameState = 'menu';
        let score = 0;
        let bestScores = JSON.parse(localStorage.getItem('flappyBestScores') || '{}');

        // Timing for frame-rate independence
        let lastTime = 0;
        const TARGET_FPS = 60;
        const FIXED_DELTA = 1000 / TARGET_FPS;

        // Scale factor
        let scale = 1;

        // Bird properties
        const bird = {
            baseX: 80,
            baseY: 250,
            baseWidth: 40,
            baseHeight: 30,
            x: 80,
            y: 250,
            width: 40,
            height: 30,
            velocity: 0,
            gravity: 0.5,
            jump: -9,
            rotation: 0,
            frame: 0,
            animTimer: 0
        };

        // Pipe properties
        const pipes = [];
        const pipeConfig = {
            baseWidth: 60,
            width: 60,
            gap: 160,
            speed: 3,
            spawnInterval: 1800,
            lastSpawn: 0
        };

        // Ground properties
        const ground = {
            baseHeight: 80,
            height: 80,
            offset: 0
        };

        // Colors
        const colors = {
            sky: '#4ec0ca',
            skyGradient: '#62d0d4',
            pipe: '#73bf2e',
            pipeDark: '#558b1f',
            pipeHighlight: '#8ed73a',
            bird: '#f7dc6f',
            birdDark: '#f39c12',
            birdWing: '#e67e22',
            ground: '#ded895',
            groundDark: '#c4b05a'
        };

        // Resize canvas
        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;

            const scaleX = containerWidth / BASE_WIDTH;
            const scaleY = containerHeight / BASE_HEIGHT;
            scale = Math.min(scaleX, scaleY);

            canvas.width = BASE_WIDTH * scale;
            canvas.height = BASE_HEIGHT * scale;

            updateScaledProperties();
        }

        function updateScaledProperties() {
            const diff = DIFFICULTIES[currentDifficulty];

            bird.x = bird.baseX * scale;
            bird.width = bird.baseWidth * scale;
            bird.height = bird.baseHeight * scale;
            bird.gravity = diff.gravity * scale;
            bird.jump = diff.jump * scale;

            pipeConfig.width = pipeConfig.baseWidth * scale;
            pipeConfig.gap = diff.pipeGap * scale;
            pipeConfig.speed = diff.pipeSpeed * scale;
            pipeConfig.spawnInterval = diff.spawnInterval;

            ground.height = ground.baseHeight * scale;

            pipes.forEach(pipe => {
                pipe.width = pipeConfig.width;
            });
        }

        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            // Difficulty buttons
            document.querySelectorAll('.diff-btn[data-difficulty]').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    startGame(btn.dataset.difficulty);
                });
                btn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    startGame(btn.dataset.difficulty);
                });
            });

            restartBtn.addEventListener('click', () => restartGame());
            restartBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                restartGame();
            });

            changeDiffBtn.addEventListener('click', () => showDifficultyMenu());
            changeDiffBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                showDifficultyMenu();
            });

            canvas.addEventListener('click', handleInput);
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                handleInput();
            });

            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space' || e.key === ' ') {
                    e.preventDefault();
                    if (gameState === 'playing') handleInput();
                    else if (gameState === 'gameover') restartGame();
                }
            });

            requestAnimationFrame(gameLoop);
        }

        function startGame(difficulty) {
            currentDifficulty = difficulty;
            gameState = 'playing';
            difficultyScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            updateScaledProperties();
            resetGame();
        }

        function restartGame() {
            gameState = 'playing';
            gameOverScreen.classList.add('hidden');
            resetGame();
        }

        function showDifficultyMenu() {
            gameState = 'menu';
            gameOverScreen.classList.add('hidden');
            difficultyScreen.classList.remove('hidden');
        }

        function resetGame() {
            bird.y = bird.baseY * scale;
            bird.velocity = 0;
            bird.rotation = 0;
            pipes.length = 0;
            score = 0;
            pipeConfig.lastSpawn = 0;
        }

        function handleInput() {
            if (gameState === 'playing') {
                bird.velocity = bird.jump;
            }
        }

        function gameOver() {
            gameState = 'gameover';

            const key = `best_${currentDifficulty}`;
            const currentBest = bestScores[key] || 0;
            const isNewRecord = score > currentBest;

            if (isNewRecord) {
                bestScores[key] = score;
                localStorage.setItem('flappyBestScores', JSON.stringify(bestScores));
            }

            finalScoreEl.textContent = score;
            bestScoreEl.textContent = bestScores[key] || 0;

            // Update badge
            const diff = DIFFICULTIES[currentDifficulty];
            difficultyBadge.textContent = diff.name;
            difficultyBadge.className = `difficulty-badge badge-${currentDifficulty}`;

            if (isNewRecord && score > 0) {
                newRecordText.classList.remove('hidden');
            } else {
                newRecordText.classList.add('hidden');
            }

            gameOverScreen.classList.remove('hidden');

            // Send score to Telegram
            if (tg && tg.sendData) {
                try {
                    tg.sendData(JSON.stringify({
                        score: score,
                        difficulty: currentDifficulty
                    }));
                } catch (e) {
                    console.log('Could not send data to Telegram');
                }
            }
        }

        function gameLoop(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            const timeMultiplier = deltaTime / FIXED_DELTA;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawBackground();

            if (gameState === 'playing') {
                update(timeMultiplier);
            }

            drawPipes();
            drawGround(timeMultiplier);
            drawBird(timeMultiplier);
            drawScore();

            requestAnimationFrame(gameLoop);
        }

        function update(timeMultiplier) {
            bird.velocity += bird.gravity * timeMultiplier;
            bird.y += bird.velocity * timeMultiplier;

            const maxVelocity = 12 * scale;
            bird.velocity = Math.max(-maxVelocity, Math.min(maxVelocity, bird.velocity));

            const targetRotation = Math.min(Math.max(bird.velocity * 3, -30), 90);
            bird.rotation += (targetRotation - bird.rotation) * 0.1 * timeMultiplier;

            if (bird.y < 0) {
                bird.y = 0;
                bird.velocity = 0;
            }

            const groundY = canvas.height - ground.height;
            if (bird.y + bird.height > groundY) {
                bird.y = groundY - bird.height;
                gameOver();
                return;
            }

            pipeConfig.lastSpawn += FIXED_DELTA * timeMultiplier;
            if (pipeConfig.lastSpawn >= pipeConfig.spawnInterval) {
                spawnPipe();
                pipeConfig.lastSpawn = 0;
            }

            for (let i = pipes.length - 1; i >= 0; i--) {
                const pipe = pipes[i];
                pipe.x -= pipeConfig.speed * timeMultiplier;

                if (!pipe.passed && pipe.x + pipe.width < bird.x) {
                    pipe.passed = true;
                    score++;
                }

                if (pipe.x + pipe.width < 0) {
                    pipes.splice(i, 1);
                }

                if (checkCollision(pipe)) {
                    gameOver();
                    return;
                }
            }
        }

        function spawnPipe() {
            const minY = 80 * scale;
            const maxY = canvas.height - ground.height - pipeConfig.gap - minY;
            const topHeight = minY + Math.random() * maxY;

            pipes.push({
                x: canvas.width,
                topHeight: topHeight,
                bottomY: topHeight + pipeConfig.gap,
                width: pipeConfig.width,
                passed: false
            });
        }

        function checkCollision(pipe) {
            const birdBox = {
                x: bird.x + 5 * scale,
                y: bird.y + 5 * scale,
                width: bird.width - 10 * scale,
                height: bird.height - 10 * scale
            };

            if (birdBox.x < pipe.x + pipe.width &&
                birdBox.x + birdBox.width > pipe.x &&
                birdBox.y < pipe.topHeight) {
                return true;
            }

            if (birdBox.x < pipe.x + pipe.width &&
                birdBox.x + birdBox.width > pipe.x &&
                birdBox.y + birdBox.height > pipe.bottomY) {
                return true;
            }

            return false;
        }

        function drawBackground() {
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, colors.skyGradient);
            gradient.addColorStop(1, colors.sky);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            drawCloud(50 * scale, 80 * scale, 60 * scale);
            drawCloud(200 * scale, 120 * scale, 80 * scale);
            drawCloud(320 * scale, 60 * scale, 50 * scale);
        }

        function drawCloud(x, y, size) {
            ctx.beginPath();
            ctx.arc(x, y, size * 0.5, 0, Math.PI * 2);
            ctx.arc(x + size * 0.4, y - size * 0.1, size * 0.4, 0, Math.PI * 2);
            ctx.arc(x + size * 0.8, y, size * 0.45, 0, Math.PI * 2);
            ctx.arc(x + size * 0.4, y + size * 0.2, size * 0.35, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawPipes() {
            pipes.forEach(pipe => {
                const capHeight = 30 * scale;
                const capOverhang = 5 * scale;

                ctx.fillStyle = colors.pipe;
                ctx.fillRect(pipe.x, 0, pipe.width, pipe.topHeight - capHeight);

                ctx.fillRect(pipe.x - capOverhang, pipe.topHeight - capHeight, pipe.width + capOverhang * 2, capHeight);

                ctx.fillStyle = colors.pipeHighlight;
                ctx.fillRect(pipe.x + 5 * scale, 0, 8 * scale, pipe.topHeight - capHeight);

                ctx.fillStyle = colors.pipeDark;
                ctx.fillRect(pipe.x + pipe.width - 10 * scale, 0, 10 * scale, pipe.topHeight - capHeight);

                ctx.strokeStyle = colors.pipeDark;
                ctx.lineWidth = 2 * scale;
                ctx.strokeRect(pipe.x - capOverhang, pipe.topHeight - capHeight, pipe.width + capOverhang * 2, capHeight);

                ctx.fillStyle = colors.pipe;
                ctx.fillRect(pipe.x, pipe.bottomY + capHeight, pipe.width, canvas.height - pipe.bottomY - capHeight - ground.height);

                ctx.fillRect(pipe.x - capOverhang, pipe.bottomY, pipe.width + capOverhang * 2, capHeight);

                ctx.fillStyle = colors.pipeHighlight;
                ctx.fillRect(pipe.x + 5 * scale, pipe.bottomY + capHeight, 8 * scale, canvas.height - pipe.bottomY - capHeight - ground.height);

                ctx.fillStyle = colors.pipeDark;
                ctx.fillRect(pipe.x + pipe.width - 10 * scale, pipe.bottomY + capHeight, 10 * scale, canvas.height - pipe.bottomY - capHeight - ground.height);

                ctx.strokeStyle = colors.pipeDark;
                ctx.strokeRect(pipe.x - capOverhang, pipe.bottomY, pipe.width + capOverhang * 2, capHeight);
            });
        }

        function drawGround(timeMultiplier) {
            const groundY = canvas.height - ground.height;

            if (gameState === 'playing') {
                ground.offset -= pipeConfig.speed * timeMultiplier;
                if (ground.offset <= -24 * scale) {
                    ground.offset = 0;
                }
            }

            ctx.fillStyle = colors.ground;
            ctx.fillRect(0, groundY, canvas.width, ground.height);

            ctx.fillStyle = colors.groundDark;
            ctx.fillRect(0, groundY, canvas.width, 5 * scale);

            ctx.fillStyle = colors.groundDark;
            for (let x = ground.offset; x < canvas.width + 24 * scale; x += 24 * scale) {
                ctx.beginPath();
                ctx.moveTo(x, groundY + 5 * scale);
                ctx.lineTo(x + 12 * scale, groundY + 20 * scale);
                ctx.lineTo(x + 24 * scale, groundY + 5 * scale);
                ctx.fill();
            }
        }

        function drawBird(timeMultiplier) {
            if (gameState === 'playing') {
                bird.animTimer += timeMultiplier;
                if (bird.animTimer > 8) {
                    bird.frame = (bird.frame + 1) % 3;
                    bird.animTimer = 0;
                }
            }

            ctx.save();
            ctx.translate(bird.x + bird.width / 2, bird.y + bird.height / 2);
            ctx.rotate(bird.rotation * Math.PI / 180);

            ctx.fillStyle = colors.bird;
            ctx.beginPath();
            ctx.ellipse(0, 0, bird.width / 2, bird.height / 2, 0, 0, Math.PI * 2);
            ctx.fill();

            ctx.strokeStyle = colors.birdDark;
            ctx.lineWidth = 2 * scale;
            ctx.stroke();

            const wingOffset = [0, -3, 3][bird.frame] * scale;
            ctx.fillStyle = colors.birdWing;
            ctx.beginPath();
            ctx.ellipse(-5 * scale, wingOffset, bird.width * 0.3, bird.height * 0.25, -0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = colors.birdDark;
            ctx.lineWidth = 1.5 * scale;
            ctx.stroke();

            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(bird.width * 0.2, -bird.height * 0.1, bird.width * 0.18, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(bird.width * 0.25, -bird.height * 0.08, bird.width * 0.08, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(bird.width * 0.28, -bird.height * 0.12, bird.width * 0.03, 0, Math.PI * 2);
            ctx.fill();

            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.moveTo(bird.width * 0.35, 0);
            ctx.lineTo(bird.width * 0.55, bird.height * 0.05);
            ctx.lineTo(bird.width * 0.35, bird.height * 0.15);
            ctx.closePath();
            ctx.fill();

            ctx.strokeStyle = '#c0392b';
            ctx.lineWidth = 1 * scale;
            ctx.beginPath();
            ctx.moveTo(bird.width * 0.35, bird.height * 0.05);
            ctx.lineTo(bird.width * 0.52, bird.height * 0.05);
            ctx.stroke();

            ctx.restore();
        }

        function drawScore() {
            if (gameState === 'playing') {
                ctx.fillStyle = '#fff';
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 4 * scale;
                ctx.font = `bold ${48 * scale}px Arial`;
                ctx.textAlign = 'center';

                const scoreText = score.toString();
                ctx.strokeText(scoreText, canvas.width / 2, 70 * scale);
                ctx.fillText(scoreText, canvas.width / 2, 70 * scale);
            }
        }

        init();
    </script>
</body>
</html>
