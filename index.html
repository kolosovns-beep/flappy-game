<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <title>Flappy Bird</title>
    <script src="https://telegram.org/js/telegram-web-app.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #4ec0ca;
            touch-action: manipulation;
        }

        #gameContainer {
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        #gameCanvas {
            display: block;
            background: #4ec0ca;
        }

        #startScreen, #gameOverScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.5);
            z-index: 10;
        }

        .screen-content {
            background: linear-gradient(180deg, #f7dc6f 0%, #f39c12 100%);
            border-radius: 20px;
            padding: 30px 40px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            border: 4px solid #fff;
        }

        .title {
            font-family: 'Arial Black', sans-serif;
            font-size: 32px;
            color: #fff;
            text-shadow: 3px 3px 0 #2c3e50, -1px -1px 0 #2c3e50;
            margin-bottom: 20px;
        }

        .score-display {
            font-family: 'Arial Black', sans-serif;
            font-size: 48px;
            color: #fff;
            text-shadow: 2px 2px 0 #2c3e50;
            margin: 10px 0;
        }

        .label {
            font-family: Arial, sans-serif;
            font-size: 16px;
            color: #2c3e50;
            margin-top: 10px;
        }

        .best-score {
            font-family: 'Arial Black', sans-serif;
            font-size: 24px;
            color: #27ae60;
            text-shadow: 1px 1px 0 #fff;
        }

        .play-btn {
            background: linear-gradient(180deg, #27ae60 0%, #1e8449 100%);
            border: 3px solid #fff;
            border-radius: 15px;
            padding: 15px 50px;
            font-family: 'Arial Black', sans-serif;
            font-size: 24px;
            color: #fff;
            text-shadow: 2px 2px 0 #1e8449;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            transition: transform 0.1s;
        }

        .play-btn:active {
            transform: scale(0.95);
        }

        .instruction {
            font-family: Arial, sans-serif;
            font-size: 14px;
            color: #fff;
            margin-top: 15px;
            opacity: 0.9;
        }

        .hidden {
            display: none !important;
        }

        .new-record {
            color: #e74c3c;
            font-family: 'Arial Black', sans-serif;
            font-size: 20px;
            text-shadow: 1px 1px 0 #fff;
            animation: pulse 0.5s ease-in-out infinite alternate;
        }

        @keyframes pulse {
            from { transform: scale(1); }
            to { transform: scale(1.1); }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>

        <div id="startScreen">
            <div class="screen-content">
                <div class="title">FLAPPY BIRD</div>
                <div class="instruction">Тапни, чтобы птичка летела</div>
                <button class="play-btn" id="startBtn">ИГРАТЬ</button>
            </div>
        </div>

        <div id="gameOverScreen" class="hidden">
            <div class="screen-content">
                <div class="title">GAME OVER</div>
                <div class="label">Очки</div>
                <div class="score-display" id="finalScore">0</div>
                <div id="newRecordText" class="new-record hidden">НОВЫЙ РЕКОРД!</div>
                <div class="label">Лучший результат</div>
                <div class="best-score" id="bestScore">0</div>
                <button class="play-btn" id="restartBtn">ЗАНОВО</button>
            </div>
        </div>
    </div>

    <script>
        // Telegram WebApp initialization
        const tg = window.Telegram?.WebApp;
        if (tg) {
            tg.ready();
            tg.expand();
            tg.setHeaderColor('#4ec0ca');
            tg.setBackgroundColor('#4ec0ca');
        }

        // Game constants (will be scaled based on screen size)
        const BASE_WIDTH = 400;
        const BASE_HEIGHT = 600;

        // Canvas setup
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        // Screen elements
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');
        const finalScoreEl = document.getElementById('finalScore');
        const bestScoreEl = document.getElementById('bestScore');
        const newRecordText = document.getElementById('newRecordText');

        // Game state
        let gameState = 'start'; // 'start', 'playing', 'gameover'
        let score = 0;
        let bestScore = parseInt(localStorage.getItem('flappyBestScore') || '0');

        // Timing for frame-rate independence
        let lastTime = 0;
        const TARGET_FPS = 60;
        const FIXED_DELTA = 1000 / TARGET_FPS;

        // Scale factor
        let scale = 1;

        // Bird properties (base values, will be scaled)
        const bird = {
            baseX: 80,
            baseY: 250,
            baseWidth: 40,
            baseHeight: 30,
            x: 80,
            y: 250,
            width: 40,
            height: 30,
            velocity: 0,
            baseGravity: 0.5,
            baseJump: -9,
            gravity: 0.5,
            jump: -9,
            rotation: 0,
            frame: 0,
            animTimer: 0
        };

        // Pipe properties
        const pipes = [];
        const pipeConfig = {
            baseWidth: 60,
            baseGap: 160,
            baseSpeed: 3,
            baseSpawnInterval: 1800,
            width: 60,
            gap: 160,
            speed: 3,
            spawnInterval: 1800,
            lastSpawn: 0
        };

        // Ground properties
        const ground = {
            baseHeight: 80,
            height: 80,
            offset: 0
        };

        // Colors
        const colors = {
            sky: '#4ec0ca',
            skyGradient: '#62d0d4',
            ground: '#ded895',
            groundDark: '#c4b05a',
            pipe: '#73bf2e',
            pipeDark: '#558b1f',
            pipeHighlight: '#8ed73a',
            bird: '#f7dc6f',
            birdDark: '#f39c12',
            birdWing: '#e67e22'
        };

        // Resize canvas to fit screen
        function resizeCanvas() {
            const container = document.getElementById('gameContainer');
            const containerWidth = container.clientWidth;
            const containerHeight = container.clientHeight;

            // Calculate scale to fit the screen while maintaining aspect ratio
            const scaleX = containerWidth / BASE_WIDTH;
            const scaleY = containerHeight / BASE_HEIGHT;
            scale = Math.min(scaleX, scaleY);

            // Set canvas size
            canvas.width = BASE_WIDTH * scale;
            canvas.height = BASE_HEIGHT * scale;

            // Update scaled properties
            bird.x = bird.baseX * scale;
            bird.width = bird.baseWidth * scale;
            bird.height = bird.baseHeight * scale;
            bird.gravity = bird.baseGravity * scale;
            bird.jump = bird.baseJump * scale;

            pipeConfig.width = pipeConfig.baseWidth * scale;
            pipeConfig.gap = pipeConfig.baseGap * scale;
            pipeConfig.speed = pipeConfig.baseSpeed * scale;

            ground.height = ground.baseHeight * scale;

            // Update existing pipes
            pipes.forEach(pipe => {
                pipe.width = pipeConfig.width;
            });
        }

        // Initialize game
        function init() {
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);

            bestScoreEl.textContent = bestScore;

            // Event listeners
            startBtn.addEventListener('click', startGame);
            startBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                startGame();
            });

            restartBtn.addEventListener('click', restartGame);
            restartBtn.addEventListener('touchstart', (e) => {
                e.preventDefault();
                restartGame();
            });

            canvas.addEventListener('click', handleInput);
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                handleInput();
            });

            // Keyboard support
            document.addEventListener('keydown', (e) => {
                if (e.code === 'Space' || e.key === ' ') {
                    e.preventDefault();
                    if (gameState === 'start') startGame();
                    else if (gameState === 'playing') handleInput();
                    else if (gameState === 'gameover') restartGame();
                }
            });

            // Start render loop
            requestAnimationFrame(gameLoop);
        }

        function startGame() {
            gameState = 'playing';
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            resetGame();
        }

        function restartGame() {
            gameState = 'playing';
            gameOverScreen.classList.add('hidden');
            resetGame();
        }

        function resetGame() {
            bird.y = bird.baseY * scale;
            bird.velocity = 0;
            bird.rotation = 0;
            pipes.length = 0;
            score = 0;
            pipeConfig.lastSpawn = 0;
        }

        function handleInput() {
            if (gameState === 'playing') {
                bird.velocity = bird.jump;
            }
        }

        function gameOver() {
            gameState = 'gameover';

            const isNewRecord = score > bestScore;
            if (isNewRecord) {
                bestScore = score;
                localStorage.setItem('flappyBestScore', bestScore.toString());
            }

            finalScoreEl.textContent = score;
            bestScoreEl.textContent = bestScore;

            if (isNewRecord && score > 0) {
                newRecordText.classList.remove('hidden');
            } else {
                newRecordText.classList.add('hidden');
            }

            gameOverScreen.classList.remove('hidden');

            // Send score to Telegram bot
            if (tg && tg.sendData) {
                try {
                    tg.sendData(JSON.stringify({ score: score }));
                } catch (e) {
                    console.log('Could not send data to Telegram');
                }
            }
        }

        // Main game loop with delta time for frame-rate independence
        function gameLoop(currentTime) {
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            // Calculate time multiplier for frame-rate independence
            const timeMultiplier = deltaTime / FIXED_DELTA;

            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw background
            drawBackground();

            if (gameState === 'playing') {
                update(timeMultiplier);
            }

            // Draw game objects
            drawPipes();
            drawGround(timeMultiplier);
            drawBird(timeMultiplier);
            drawScore();

            requestAnimationFrame(gameLoop);
        }

        function update(timeMultiplier) {
            // Update bird physics
            bird.velocity += bird.gravity * timeMultiplier;
            bird.y += bird.velocity * timeMultiplier;

            // Limit velocity
            const maxVelocity = 12 * scale;
            bird.velocity = Math.max(-maxVelocity, Math.min(maxVelocity, bird.velocity));

            // Bird rotation based on velocity
            const targetRotation = Math.min(Math.max(bird.velocity * 3, -30), 90);
            bird.rotation += (targetRotation - bird.rotation) * 0.1 * timeMultiplier;

            // Check ceiling
            if (bird.y < 0) {
                bird.y = 0;
                bird.velocity = 0;
            }

            // Check ground collision
            const groundY = canvas.height - ground.height;
            if (bird.y + bird.height > groundY) {
                bird.y = groundY - bird.height;
                gameOver();
                return;
            }

            // Spawn pipes
            pipeConfig.lastSpawn += FIXED_DELTA * timeMultiplier;
            if (pipeConfig.lastSpawn >= pipeConfig.spawnInterval) {
                spawnPipe();
                pipeConfig.lastSpawn = 0;
            }

            // Update pipes
            for (let i = pipes.length - 1; i >= 0; i--) {
                const pipe = pipes[i];
                pipe.x -= pipeConfig.speed * timeMultiplier;

                // Check if bird passed the pipe
                if (!pipe.passed && pipe.x + pipe.width < bird.x) {
                    pipe.passed = true;
                    score++;
                }

                // Remove off-screen pipes
                if (pipe.x + pipe.width < 0) {
                    pipes.splice(i, 1);
                }

                // Collision detection
                if (checkCollision(pipe)) {
                    gameOver();
                    return;
                }
            }
        }

        function spawnPipe() {
            const minY = 80 * scale;
            const maxY = canvas.height - ground.height - pipeConfig.gap - minY;
            const topHeight = minY + Math.random() * maxY;

            pipes.push({
                x: canvas.width,
                topHeight: topHeight,
                bottomY: topHeight + pipeConfig.gap,
                width: pipeConfig.width,
                passed: false
            });
        }

        function checkCollision(pipe) {
            const birdBox = {
                x: bird.x + 5 * scale,
                y: bird.y + 5 * scale,
                width: bird.width - 10 * scale,
                height: bird.height - 10 * scale
            };

            // Top pipe
            if (birdBox.x < pipe.x + pipe.width &&
                birdBox.x + birdBox.width > pipe.x &&
                birdBox.y < pipe.topHeight) {
                return true;
            }

            // Bottom pipe
            if (birdBox.x < pipe.x + pipe.width &&
                birdBox.x + birdBox.width > pipe.x &&
                birdBox.y + birdBox.height > pipe.bottomY) {
                return true;
            }

            return false;
        }

        // Drawing functions
        function drawBackground() {
            // Sky gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, colors.skyGradient);
            gradient.addColorStop(1, colors.sky);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Clouds
            ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
            drawCloud(50 * scale, 80 * scale, 60 * scale);
            drawCloud(200 * scale, 120 * scale, 80 * scale);
            drawCloud(320 * scale, 60 * scale, 50 * scale);
        }

        function drawCloud(x, y, size) {
            ctx.beginPath();
            ctx.arc(x, y, size * 0.5, 0, Math.PI * 2);
            ctx.arc(x + size * 0.4, y - size * 0.1, size * 0.4, 0, Math.PI * 2);
            ctx.arc(x + size * 0.8, y, size * 0.45, 0, Math.PI * 2);
            ctx.arc(x + size * 0.4, y + size * 0.2, size * 0.35, 0, Math.PI * 2);
            ctx.fill();
        }

        function drawPipes() {
            pipes.forEach(pipe => {
                const capHeight = 30 * scale;
                const capOverhang = 5 * scale;

                // Top pipe body
                ctx.fillStyle = colors.pipe;
                ctx.fillRect(pipe.x, 0, pipe.width, pipe.topHeight - capHeight);

                // Top pipe cap
                ctx.fillStyle = colors.pipe;
                ctx.fillRect(pipe.x - capOverhang, pipe.topHeight - capHeight, pipe.width + capOverhang * 2, capHeight);

                // Top pipe highlight
                ctx.fillStyle = colors.pipeHighlight;
                ctx.fillRect(pipe.x + 5 * scale, 0, 8 * scale, pipe.topHeight - capHeight);

                // Top pipe shadow
                ctx.fillStyle = colors.pipeDark;
                ctx.fillRect(pipe.x + pipe.width - 10 * scale, 0, 10 * scale, pipe.topHeight - capHeight);

                // Top cap border
                ctx.strokeStyle = colors.pipeDark;
                ctx.lineWidth = 2 * scale;
                ctx.strokeRect(pipe.x - capOverhang, pipe.topHeight - capHeight, pipe.width + capOverhang * 2, capHeight);

                // Bottom pipe body
                ctx.fillStyle = colors.pipe;
                ctx.fillRect(pipe.x, pipe.bottomY + capHeight, pipe.width, canvas.height - pipe.bottomY - capHeight - ground.height);

                // Bottom pipe cap
                ctx.fillRect(pipe.x - capOverhang, pipe.bottomY, pipe.width + capOverhang * 2, capHeight);

                // Bottom pipe highlight
                ctx.fillStyle = colors.pipeHighlight;
                ctx.fillRect(pipe.x + 5 * scale, pipe.bottomY + capHeight, 8 * scale, canvas.height - pipe.bottomY - capHeight - ground.height);

                // Bottom pipe shadow
                ctx.fillStyle = colors.pipeDark;
                ctx.fillRect(pipe.x + pipe.width - 10 * scale, pipe.bottomY + capHeight, 10 * scale, canvas.height - pipe.bottomY - capHeight - ground.height);

                // Bottom cap border
                ctx.strokeStyle = colors.pipeDark;
                ctx.strokeRect(pipe.x - capOverhang, pipe.bottomY, pipe.width + capOverhang * 2, capHeight);
            });
        }

        function drawGround(timeMultiplier) {
            const groundY = canvas.height - ground.height;

            // Animate ground
            if (gameState === 'playing') {
                ground.offset -= pipeConfig.speed * timeMultiplier;
                if (ground.offset <= -24 * scale) {
                    ground.offset = 0;
                }
            }

            // Ground body
            ctx.fillStyle = colors.ground;
            ctx.fillRect(0, groundY, canvas.width, ground.height);

            // Ground top line
            ctx.fillStyle = colors.groundDark;
            ctx.fillRect(0, groundY, canvas.width, 5 * scale);

            // Ground pattern
            ctx.fillStyle = colors.groundDark;
            for (let x = ground.offset; x < canvas.width + 24 * scale; x += 24 * scale) {
                ctx.beginPath();
                ctx.moveTo(x, groundY + 5 * scale);
                ctx.lineTo(x + 12 * scale, groundY + 20 * scale);
                ctx.lineTo(x + 24 * scale, groundY + 5 * scale);
                ctx.fill();
            }
        }

        function drawBird(timeMultiplier) {
            // Animate wings
            if (gameState === 'playing') {
                bird.animTimer += timeMultiplier;
                if (bird.animTimer > 8) {
                    bird.frame = (bird.frame + 1) % 3;
                    bird.animTimer = 0;
                }
            }

            ctx.save();
            ctx.translate(bird.x + bird.width / 2, bird.y + bird.height / 2);
            ctx.rotate(bird.rotation * Math.PI / 180);

            // Body
            ctx.fillStyle = colors.bird;
            ctx.beginPath();
            ctx.ellipse(0, 0, bird.width / 2, bird.height / 2, 0, 0, Math.PI * 2);
            ctx.fill();

            // Body outline
            ctx.strokeStyle = colors.birdDark;
            ctx.lineWidth = 2 * scale;
            ctx.stroke();

            // Wing
            const wingOffset = [0, -3, 3][bird.frame] * scale;
            ctx.fillStyle = colors.birdWing;
            ctx.beginPath();
            ctx.ellipse(-5 * scale, wingOffset, bird.width * 0.3, bird.height * 0.25, -0.3, 0, Math.PI * 2);
            ctx.fill();
            ctx.strokeStyle = colors.birdDark;
            ctx.lineWidth = 1.5 * scale;
            ctx.stroke();

            // Eye white
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(bird.width * 0.2, -bird.height * 0.1, bird.width * 0.18, 0, Math.PI * 2);
            ctx.fill();

            // Eye black
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(bird.width * 0.25, -bird.height * 0.08, bird.width * 0.08, 0, Math.PI * 2);
            ctx.fill();

            // Eye highlight
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(bird.width * 0.28, -bird.height * 0.12, bird.width * 0.03, 0, Math.PI * 2);
            ctx.fill();

            // Beak
            ctx.fillStyle = '#e74c3c';
            ctx.beginPath();
            ctx.moveTo(bird.width * 0.35, 0);
            ctx.lineTo(bird.width * 0.55, bird.height * 0.05);
            ctx.lineTo(bird.width * 0.35, bird.height * 0.15);
            ctx.closePath();
            ctx.fill();

            // Beak line
            ctx.strokeStyle = '#c0392b';
            ctx.lineWidth = 1 * scale;
            ctx.beginPath();
            ctx.moveTo(bird.width * 0.35, bird.height * 0.05);
            ctx.lineTo(bird.width * 0.52, bird.height * 0.05);
            ctx.stroke();

            ctx.restore();
        }

        function drawScore() {
            if (gameState === 'playing') {
                ctx.fillStyle = '#fff';
                ctx.strokeStyle = '#2c3e50';
                ctx.lineWidth = 4 * scale;
                ctx.font = `bold ${48 * scale}px Arial`;
                ctx.textAlign = 'center';

                const scoreText = score.toString();
                ctx.strokeText(scoreText, canvas.width / 2, 70 * scale);
                ctx.fillText(scoreText, canvas.width / 2, 70 * scale);
            }
        }

        // Start the game
        init();
    </script>
</body>
</html>
